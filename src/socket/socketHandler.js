const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Group = require('../models/Group');
const Message = require('../models/Message');
const Notification = require('../models/Notification');

// Armazenar usu√°rios conectados e suas salas
const connectedUsers = new Map(); // userId -> socketId
const userRooms = new Map(); // userId -> Set of groupIds
const typingUsers = new Map(); // groupId -> Set of userIds

// Middleware de autentica√ß√£o para Socket.io
const authenticateSocket = async (socket, next) => {
  try {
    const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return next(new Error('Token de autentica√ß√£o necess√°rio'));
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId);
    
    if (!user) {
      return next(new Error('Usu√°rio n√£o encontrado'));
    }

    socket.userId = user.id;
    socket.user = user.toPublicObject();
    next();
  } catch (error) {
    next(new Error('Token inv√°lido'));
  }
};

// Inicializar Socket.io
const initializeSocket = (io) => {
  // Aplicar middleware de autentica√ß√£o
  io.use(authenticateSocket);

  io.on('connection', (socket) => {
    console.log(`‚úÖ Usu√°rio conectado: ${socket.user.name} (ID: ${socket.userId})`);
    
    // Armazenar conex√£o do usu√°rio
    connectedUsers.set(socket.userId, socket.id);
    userRooms.set(socket.userId, new Set());

    // Evento: Entrar em sala de chat do grupo
    socket.on('join_group', async (data) => {
      try {
        const { groupId } = data;
        
        if (!groupId) {
          socket.emit('error', { message: 'ID do grupo √© obrigat√≥rio' });
          return;
        }

        // Verificar se usu√°rio √© membro do grupo
        const isMember = await Group.isMember(groupId, socket.userId);
        if (!isMember) {
          socket.emit('error', { message: 'Voc√™ n√£o √© membro deste grupo' });
          return;
        }

        // Entrar na sala
        const roomName = `group_${groupId}`;
        socket.join(roomName);
        
        // Armazenar sala do usu√°rio
        userRooms.get(socket.userId).add(groupId);

        // Notificar outros membros que usu√°rio entrou
        socket.to(roomName).emit('user_joined', {
          user: socket.user,
          groupId: groupId,
          timestamp: new Date().toISOString()
        });

        // Enviar confirma√ß√£o para o usu√°rio
        socket.emit('joined_group', {
          groupId: groupId,
          message: 'Voc√™ entrou no chat do grupo'
        });

        console.log(`üë• ${socket.user.name} entrou no grupo ${groupId}`);
      } catch (error) {
        console.error('Erro ao entrar no grupo:', error);
        socket.emit('error', { message: 'Erro ao entrar no grupo' });
      }
    });

    // Evento: Sair da sala de chat do grupo
    socket.on('leave_group', async (data) => {
      try {
        const { groupId } = data;
        
        if (!groupId) {
          socket.emit('error', { message: 'ID do grupo √© obrigat√≥rio' });
          return;
        }

        // Sair da sala
        const roomName = `group_${groupId}`;
        socket.leave(roomName);
        
        // Remover sala do usu√°rio
        userRooms.get(socket.userId)?.delete(groupId);

        // Parar indicador de digita√ß√£o se estiver ativo
        const typingSet = typingUsers.get(groupId);
        if (typingSet) {
          typingSet.delete(socket.userId);
          if (typingSet.size === 0) {
            typingUsers.delete(groupId);
          } else {
            socket.to(roomName).emit('stop_typing', {
              userId: socket.userId,
              groupId: groupId
            });
          }
        }

        // Notificar outros membros que usu√°rio saiu
        socket.to(roomName).emit('user_left', {
          user: socket.user,
          groupId: groupId,
          timestamp: new Date().toISOString()
        });

        // Enviar confirma√ß√£o para o usu√°rio
        socket.emit('left_group', {
          groupId: groupId,
          message: 'Voc√™ saiu do chat do grupo'
        });

        console.log(`üëã ${socket.user.name} saiu do grupo ${groupId}`);
      } catch (error) {
        console.error('Erro ao sair do grupo:', error);
        socket.emit('error', { message: 'Erro ao sair do grupo' });
      }
    });

    // Evento: Enviar mensagem
    socket.on('send_message', async (data) => {
      try {
        const { groupId, message } = data;
        
        if (!groupId || !message || message.trim().length === 0) {
          socket.emit('error', { message: 'Grupo e mensagem s√£o obrigat√≥rios' });
          return;
        }

        // Verificar se usu√°rio √© membro do grupo
        const isMember = await Group.isMember(groupId, socket.userId);
        if (!isMember) {
          socket.emit('error', { message: 'Voc√™ n√£o √© membro deste grupo' });
          return;
        }

        // Salvar mensagem no banco
        const messageId = await Message.create({
          groupId: groupId,
          userId: socket.userId,
          message: message.trim()
        });

        // Buscar mensagem completa
        const savedMessage = await Message.findById(messageId);

        // Enviar mensagem para todos os membros da sala
        const roomName = `group_${groupId}`;
        io.to(roomName).emit('new_message', {
          message: savedMessage,
          groupId: groupId
        });

        // Criar notifica√ß√£o para membros offline
        const members = await Group.getGroupMembers(groupId);
        const onlineMembers = new Set();
        
        // Identificar membros online
        for (const [userId, socketId] of connectedUsers) {
          if (members.some(member => member.id === userId)) {
            onlineMembers.add(userId);
          }
        }

        // Criar notifica√ß√£o para membros offline
        const offlineMembers = members
          .filter(member => !onlineMembers.has(member.id) && member.id !== socket.userId)
          .map(member => member.id);

        if (offlineMembers.length > 0) {
          await Notification.createForMultipleUsers(offlineMembers, {
            type: 'new_message',
            message: `Nova mensagem no grupo "${savedMessage.groupId}"`,
            data: {
              groupId: groupId,
              messageId: messageId,
              senderId: socket.userId,
              senderName: socket.user.name,
              message: message.trim()
            }
          });
        }

        console.log(`üí¨ ${socket.user.name} enviou mensagem no grupo ${groupId}`);
      } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        socket.emit('error', { message: 'Erro ao enviar mensagem' });
      }
    });

    // Evento: Indicador de digita√ß√£o
    socket.on('typing', async (data) => {
      try {
        const { groupId } = data;
        
        if (!groupId) {
          return;
        }

        // Verificar se usu√°rio √© membro do grupo
        const isMember = await Group.isMember(groupId, socket.userId);
        if (!isMember) {
          return;
        }

        // Adicionar usu√°rio aos que est√£o digitando
        if (!typingUsers.has(groupId)) {
          typingUsers.set(groupId, new Set());
        }
        typingUsers.get(groupId).add(socket.userId);

        // Notificar outros membros
        const roomName = `group_${groupId}`;
        socket.to(roomName).emit('typing', {
          userId: socket.userId,
          userName: socket.user.name,
          groupId: groupId
        });

        // Remover indicador ap√≥s 3 segundos
        setTimeout(() => {
          const typingSet = typingUsers.get(groupId);
          if (typingSet) {
            typingSet.delete(socket.userId);
            if (typingSet.size === 0) {
              typingUsers.delete(groupId);
            } else {
              socket.to(roomName).emit('stop_typing', {
                userId: socket.userId,
                groupId: groupId
              });
            }
          }
        }, 3000);
      } catch (error) {
        console.error('Erro no indicador de digita√ß√£o:', error);
      }
    });

    // Evento: Parar indicador de digita√ß√£o
    socket.on('stop_typing', (data) => {
      try {
        const { groupId } = data;
        
        if (!groupId) {
          return;
        }

        const typingSet = typingUsers.get(groupId);
        if (typingSet) {
          typingSet.delete(socket.userId);
          if (typingSet.size === 0) {
            typingUsers.delete(groupId);
          } else {
            const roomName = `group_${groupId}`;
            socket.to(roomName).emit('stop_typing', {
              userId: socket.userId,
              groupId: groupId
            });
          }
        }
      } catch (error) {
        console.error('Erro ao parar indicador de digita√ß√£o:', error);
      }
    });

    // Evento: Obter hist√≥rico de mensagens
    socket.on('get_messages', async (data) => {
      try {
        const { groupId, page = 1, limit = 50 } = data;
        
        if (!groupId) {
          socket.emit('error', { message: 'ID do grupo √© obrigat√≥rio' });
          return;
        }

        // Verificar se usu√°rio √© membro do grupo
        const isMember = await Group.isMember(groupId, socket.userId);
        if (!isMember) {
          socket.emit('error', { message: 'Voc√™ n√£o √© membro deste grupo' });
          return;
        }

        // Buscar mensagens
        const messages = await Message.findByGroupId(groupId, page, limit);

        socket.emit('messages_history', {
          groupId: groupId,
          messages: messages,
          page: page,
          limit: limit
        });
      } catch (error) {
        console.error('Erro ao buscar mensagens:', error);
        socket.emit('error', { message: 'Erro ao buscar mensagens' });
      }
    });

    // Evento: Desconex√£o
    socket.on('disconnect', () => {
      console.log(`‚ùå Usu√°rio desconectado: ${socket.user.name} (ID: ${socket.userId})`);
      
      // Remover usu√°rio das conex√µes
      connectedUsers.delete(socket.userId);
      
      // Notificar grupos que usu√°rio saiu
      const userGroups = userRooms.get(socket.userId);
      if (userGroups) {
        userGroups.forEach(groupId => {
          const roomName = `group_${groupId}`;
          socket.to(roomName).emit('user_left', {
            user: socket.user,
            groupId: groupId,
            timestamp: new Date().toISOString()
          });
        });
        userRooms.delete(socket.userId);
      }

      // Limpar indicadores de digita√ß√£o
      typingUsers.forEach((typingSet, groupId) => {
        typingSet.delete(socket.userId);
        if (typingSet.size === 0) {
          typingUsers.delete(groupId);
        }
      });
    });
  });

  console.log('üîå Socket.io inicializado com sucesso');
};

// Fun√ß√£o para enviar notifica√ß√£o para usu√°rio espec√≠fico
const sendNotificationToUser = (userId, notification) => {
  const socketId = connectedUsers.get(userId);
  if (socketId) {
    const io = require('socket.io');
    io.to(socketId).emit('notification', notification);
  }
};

// Fun√ß√£o para enviar notifica√ß√£o para grupo
const sendNotificationToGroup = (groupId, notification) => {
  const roomName = `group_${groupId}`;
  const io = require('socket.io');
  io.to(roomName).emit('group_notification', notification);
};

module.exports = {
  initializeSocket,
  sendNotificationToUser,
  sendNotificationToGroup,
  connectedUsers,
  userRooms
};
